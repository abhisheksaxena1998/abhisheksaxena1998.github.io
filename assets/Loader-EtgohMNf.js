import{r,e as we,R as re,j as Z}from"./index-DXhpwDZ2.js";import{u as Ee,e as We,Z as Ce,V as D,o as ce,n as le,h as Re,ao as L}from"./Preload-BMDkQqJA.js";import{_ as Te}from"./extends-CF3RwP-h.js";const T=new D,G=new D,Oe=new D,oe=new Re;function $e(e,t,n){const s=T.setFromMatrixPosition(e.matrixWorld);s.project(t);const i=n.width/2,c=n.height/2;return[s.x*i+i,-(s.y*c)+c]}function Fe(e,t){const n=T.setFromMatrixPosition(e.matrixWorld),s=G.setFromMatrixPosition(t.matrixWorld),i=n.sub(s),c=t.getWorldDirection(Oe);return i.angleTo(c)>Math.PI/2}function Ve(e,t,n,s){const i=T.setFromMatrixPosition(e.matrixWorld),c=i.clone();c.project(t),oe.set(c.x,c.y),n.setFromCamera(oe,t);const x=n.intersectObjects(s,!0);if(x.length){const g=x[0].distance;return i.distanceTo(n.ray.origin)<g}return!0}function Ie(e,t){if(t instanceof ce)return t.zoom;if(t instanceof le){const n=T.setFromMatrixPosition(e.matrixWorld),s=G.setFromMatrixPosition(t.matrixWorld),i=t.fov*Math.PI/180,c=n.distanceTo(s);return 1/(2*Math.tan(i/2)*c)}else return 1}function He(e,t,n){if(t instanceof le||t instanceof ce){const s=T.setFromMatrixPosition(e.matrixWorld),i=G.setFromMatrixPosition(t.matrixWorld),c=s.distanceTo(i),x=(n[1]-n[0])/(t.far-t.near),g=n[1]-x*t.far;return Math.round(x*c+g)}}const _=e=>Math.abs(e)<1e-10?0:e;function ue(e,t,n=""){let s="matrix3d(";for(let i=0;i!==16;i++)s+=_(t[i]*e.elements[i])+(i!==15?",":")");return n+s}const Le=(e=>t=>ue(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),De=(e=>(t,n)=>ue(t,e(n),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function ze(e){return e&&typeof e=="object"&&"current"in e}const Ae=r.forwardRef(({children:e,eps:t=.001,style:n,className:s,prepend:i,center:c,fullscreen:x,portal:g,distanceFactor:M,sprite:y=!1,transform:l=!1,occlude:a,onOcclude:O,castShadow:z,receiveShadow:de,material:fe,geometry:q,zIndexRange:$=[16777271,0],calculatePosition:J=$e,as:me="div",wrapperClass:A,pointerEvents:K="auto",...v},Q)=>{const{gl:U,camera:u,scene:X,size:f,raycaster:he,events:xe,viewport:ge}=Ee(),[d]=r.useState(()=>document.createElement(me)),N=r.useRef(),h=r.useRef(null),Y=r.useRef(0),F=r.useRef([0,0]),W=r.useRef(null),k=r.useRef(null),w=(g==null?void 0:g.current)||xe.connected||U.domElement.parentNode,b=r.useRef(null),V=r.useRef(!1),I=r.useMemo(()=>a&&a!=="blending"||Array.isArray(a)&&a.length&&ze(a[0]),[a]);r.useLayoutEffect(()=>{const m=U.domElement;a&&a==="blending"?(m.style.zIndex=`${Math.floor($[0]/2)}`,m.style.position="absolute",m.style.pointerEvents="none"):(m.style.zIndex=null,m.style.position=null,m.style.pointerEvents=null)},[a]),r.useLayoutEffect(()=>{if(h.current){const m=N.current=we.createRoot(d);if(X.updateMatrixWorld(),l)d.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const o=J(h.current,u,f);d.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${o[0]}px,${o[1]}px,0);transform-origin:0 0;`}return w&&(i?w.prepend(d):w.appendChild(d)),()=>{w&&w.removeChild(d),m.unmount()}}},[w,l]),r.useLayoutEffect(()=>{A&&(d.className=A)},[A]);const ee=r.useMemo(()=>l?{position:"absolute",top:0,left:0,width:f.width,height:f.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:c?"translate3d(-50%,-50%,0)":"none",...x&&{top:-f.height/2,left:-f.width/2,width:f.width,height:f.height},...n},[n,c,x,f,l]),ve=r.useMemo(()=>({position:"absolute",pointerEvents:K}),[K]);r.useLayoutEffect(()=>{if(V.current=!1,l){var m;(m=N.current)==null||m.render(r.createElement("div",{ref:W,style:ee},r.createElement("div",{ref:k,style:ve},r.createElement("div",{ref:Q,className:s,style:n,children:e}))))}else{var o;(o=N.current)==null||o.render(r.createElement("div",{ref:Q,style:ee,className:s,children:e}))}});const E=r.useRef(!0);We(m=>{if(h.current){u.updateMatrixWorld(),h.current.updateWorldMatrix(!0,!1);const o=l?F.current:J(h.current,u,f);if(l||Math.abs(Y.current-u.zoom)>t||Math.abs(F.current[0]-o[0])>t||Math.abs(F.current[1]-o[1])>t){const P=Fe(h.current,u);let p=!1;I&&(Array.isArray(a)?p=a.map(S=>S.current):a!=="blending"&&(p=[X]));const C=E.current;if(p){const S=Ve(h.current,u,he,p);E.current=S&&!P}else E.current=!P;C!==E.current&&(O?O(!E.current):d.style.display=E.current?"block":"none");const H=Math.floor($[0]/2),pe=a?I?[$[0],H]:[H-1,0]:$;if(d.style.zIndex=`${He(h.current,u,pe)}`,l){const[S,ne]=[f.width/2,f.height/2],B=u.projectionMatrix.elements[5]*ne,{isOrthographicCamera:se,top:ye,left:be,bottom:Me,right:Pe}=u,Se=Le(u.matrixWorldInverse),je=se?`scale(${B})translate(${_(-(Pe+be)/2)}px,${_((ye+Me)/2)}px)`:`translateZ(${B}px)`;let j=h.current.matrixWorld;y&&(j=u.matrixWorldInverse.clone().transpose().copyPosition(j).scale(h.current.scale),j.elements[3]=j.elements[7]=j.elements[11]=0,j.elements[15]=1),d.style.width=f.width+"px",d.style.height=f.height+"px",d.style.perspective=se?"":`${B}px`,W.current&&k.current&&(W.current.style.transform=`${je}${Se}translate(${S}px,${ne}px)`,k.current.style.transform=De(j,1/((M||10)/400)))}else{const S=M===void 0?1:Ie(h.current,u)*M;d.style.transform=`translate3d(${o[0]}px,${o[1]}px,0) scale(${S})`}F.current=o,Y.current=u.zoom}}if(!I&&b.current&&!V.current)if(l){if(W.current){const o=W.current.children[0];if(o!=null&&o.clientWidth&&o!=null&&o.clientHeight){const{isOrthographicCamera:P}=u;if(P||q)v.scale&&(Array.isArray(v.scale)?v.scale instanceof D?b.current.scale.copy(v.scale.clone().divideScalar(1)):b.current.scale.set(1/v.scale[0],1/v.scale[1],1/v.scale[2]):b.current.scale.setScalar(1/v.scale));else{const p=(M||10)/400,C=o.clientWidth*p,H=o.clientHeight*p;b.current.scale.set(C,H,1)}V.current=!0}}}else{const o=d.children[0];if(o!=null&&o.clientWidth&&o!=null&&o.clientHeight){const P=1/ge.factor,p=o.clientWidth*P,C=o.clientHeight*P;b.current.scale.set(p,C,1),V.current=!0}b.current.lookAt(m.camera.position)}});const te=r.useMemo(()=>({vertexShader:l?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[l]);return r.createElement("group",Te({},v,{ref:h}),a&&!I&&r.createElement("mesh",{castShadow:z,receiveShadow:de,ref:b},q||r.createElement("planeGeometry",null),fe||r.createElement("shaderMaterial",{side:Ce,vertexShader:te.vertexShader,fragmentShader:te.fragmentShader})))}),ie=e=>{let t;const n=new Set,s=(y,l)=>{const a=typeof y=="function"?y(t):y;if(!Object.is(a,t)){const O=t;t=l??(typeof a!="object"||a===null)?a:Object.assign({},t,a),n.forEach(z=>z(t,O))}},i=()=>t,g={setState:s,getState:i,getInitialState:()=>M,subscribe:y=>(n.add(y),()=>n.delete(y))},M=t=e(s,i,g);return g},Ne=e=>e?ie(e):ie,ke=e=>e;function Be(e,t=ke){const n=re.useSyncExternalStore(e.subscribe,()=>t(e.getState()),()=>t(e.getInitialState()));return re.useDebugValue(n),n}const ae=e=>{const t=Ne(e),n=s=>Be(t,s);return Object.assign(n,t),n},Ze=e=>e?ae(e):ae;let R=0;const _e=Ze(e=>(L.onStart=(t,n,s)=>{e({active:!0,item:t,loaded:n,total:s,progress:(n-R)/(s-R)*100})},L.onLoad=()=>{e({active:!1})},L.onError=t=>e(n=>({errors:[...n.errors,t]})),L.onProgress=(t,n,s)=>{n===s&&(R=s),e({active:!0,item:t,loaded:n,total:s,progress:(n-R)/(s-R)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0})),Ge=(e,t)=>{const[n,s]=r.useState(e);return r.useEffect(()=>{const i=setTimeout(()=>{s(e)},t);return()=>{clearTimeout(i)}},[e,t]),n},qe=()=>{const{progress:e}=_e(),t=Ge(e,100);return Z.jsxs(Ae,{as:"div",center:!0,style:{display:"flex",justifyContent:"center",alignItems:"center",flexDirection:"column"},children:[Z.jsx("span",{className:"canvas-loader"}),Z.jsxs("p",{className:"loader-text",children:[t.toFixed(2),"%"]})]})},Ue=r.memo(qe);export{Ue as default};
