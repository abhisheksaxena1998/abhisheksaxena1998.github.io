import{r as n,e as Pe,j as N}from"./index-8HtWgTNX.js";import{u as be,d as Se,Y as we,V as z,m as re,l as ne,ao as je,ap as L}from"./Preload-J16uAnyv.js";import{_ as Ee}from"./extends-dGVwEr9R.js";const R=new z,B=new z,We=new z;function Ce(e,t,r){const s=R.setFromMatrixPosition(e.matrixWorld);s.project(t);const i=r.width/2,a=r.height/2;return[s.x*i+i,-(s.y*a)+a]}function Re(e,t){const r=R.setFromMatrixPosition(e.matrixWorld),s=B.setFromMatrixPosition(t.matrixWorld),i=r.sub(s),a=t.getWorldDirection(We);return i.angleTo(a)>Math.PI/2}function $e(e,t,r,s){const i=R.setFromMatrixPosition(e.matrixWorld),a=i.clone();a.project(t),r.setFromCamera(a,t);const x=r.intersectObjects(s,!0);if(x.length){const b=x[0].distance;return i.distanceTo(r.ray.origin)<b}return!0}function Oe(e,t){if(t instanceof re)return t.zoom;if(t instanceof ne){const r=R.setFromMatrixPosition(e.matrixWorld),s=B.setFromMatrixPosition(t.matrixWorld),i=t.fov*Math.PI/180,a=r.distanceTo(s);return 1/(2*Math.tan(i/2)*a)}else return 1}function Te(e,t,r){if(t instanceof ne||t instanceof re){const s=R.setFromMatrixPosition(e.matrixWorld),i=B.setFromMatrixPosition(t.matrixWorld),a=s.distanceTo(i),x=(r[1]-r[0])/(t.far-t.near),b=r[1]-x*t.far;return Math.round(x*a+b)}}const k=e=>Math.abs(e)<1e-10?0:e;function se(e,t,r=""){let s="matrix3d(";for(let i=0;i!==16;i++)s+=k(t[i]*e.elements[i])+(i!==15?",":")");return r+s}const Fe=(e=>t=>se(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),He=(e=>(t,r)=>se(t,e(r),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Le(e){return e&&typeof e=="object"&&"current"in e}const ze=n.forwardRef(({children:e,eps:t=.001,style:r,className:s,prepend:i,center:a,fullscreen:x,portal:b,distanceFactor:j,sprite:oe=!1,transform:h=!1,occlude:c,onOcclude:Z,castShadow:ie,receiveShadow:ae,material:ce,geometry:_,zIndexRange:$=[16777271,0],calculatePosition:G=Ce,as:le="div",wrapperClass:A,pointerEvents:Y="auto",...v},q)=>{const{gl:J,camera:l,scene:K,size:f,raycaster:ue,events:fe,viewport:de}=be(),[u]=n.useState(()=>document.createElement(le)),D=n.useRef(),m=n.useRef(null),Q=n.useRef(0),O=n.useRef([0,0]),E=n.useRef(null),V=n.useRef(null),S=(b==null?void 0:b.current)||fe.connected||J.domElement.parentNode,g=n.useRef(null),T=n.useRef(!1),F=n.useMemo(()=>c&&c!=="blending"||Array.isArray(c)&&c.length&&Le(c[0]),[c]);n.useLayoutEffect(()=>{const d=J.domElement;c&&c==="blending"?(d.style.zIndex=`${Math.floor($[0]/2)}`,d.style.position="absolute",d.style.pointerEvents="none"):(d.style.zIndex=null,d.style.position=null,d.style.pointerEvents=null)},[c]),n.useLayoutEffect(()=>{if(m.current){const d=D.current=Pe(u);if(K.updateMatrixWorld(),h)u.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const o=G(m.current,l,f);u.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${o[0]}px,${o[1]}px,0);transform-origin:0 0;`}return S&&(i?S.prepend(u):S.appendChild(u)),()=>{S&&S.removeChild(u),d.unmount()}}},[S,h]),n.useLayoutEffect(()=>{A&&(u.className=A)},[A]);const U=n.useMemo(()=>h?{position:"absolute",top:0,left:0,width:f.width,height:f.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:a?"translate3d(-50%,-50%,0)":"none",...x&&{top:-f.height/2,left:-f.width/2,width:f.width,height:f.height},...r},[r,a,x,f,h]),me=n.useMemo(()=>({position:"absolute",pointerEvents:Y}),[Y]);n.useLayoutEffect(()=>{if(T.current=!1,h){var d;(d=D.current)==null||d.render(n.createElement("div",{ref:E,style:U},n.createElement("div",{ref:V,style:me},n.createElement("div",{ref:q,className:s,style:r,children:e}))))}else{var o;(o=D.current)==null||o.render(n.createElement("div",{ref:q,style:U,className:s,children:e}))}});const w=n.useRef(!0);Se(d=>{if(m.current){l.updateMatrixWorld(),m.current.updateWorldMatrix(!0,!1);const o=h?O.current:G(m.current,l,f);if(h||Math.abs(Q.current-l.zoom)>t||Math.abs(O.current[0]-o[0])>t||Math.abs(O.current[1]-o[1])>t){const y=Re(m.current,l);let p=!1;F&&(Array.isArray(c)?p=c.map(M=>M.current):c!=="blending"&&(p=[K]));const W=w.current;if(p){const M=$e(m.current,l,ue,p);w.current=M&&!y}else w.current=!y;W!==w.current&&(Z?Z(!w.current):u.style.display=w.current?"block":"none");const H=Math.floor($[0]/2),he=c?F?[$[0],H]:[H-1,0]:$;if(u.style.zIndex=`${Te(m.current,l,he)}`,h){const[M,ee]=[f.width/2,f.height/2],I=l.projectionMatrix.elements[5]*ee,{isOrthographicCamera:te,top:xe,left:ve,bottom:pe,right:ge}=l,ye=Fe(l.matrixWorldInverse),Me=te?`scale(${I})translate(${k(-(ge+ve)/2)}px,${k((xe+pe)/2)}px)`:`translateZ(${I}px)`;let P=m.current.matrixWorld;oe&&(P=l.matrixWorldInverse.clone().transpose().copyPosition(P).scale(m.current.scale),P.elements[3]=P.elements[7]=P.elements[11]=0,P.elements[15]=1),u.style.width=f.width+"px",u.style.height=f.height+"px",u.style.perspective=te?"":`${I}px`,E.current&&V.current&&(E.current.style.transform=`${Me}${ye}translate(${M}px,${ee}px)`,V.current.style.transform=He(P,1/((j||10)/400)))}else{const M=j===void 0?1:Oe(m.current,l)*j;u.style.transform=`translate3d(${o[0]}px,${o[1]}px,0) scale(${M})`}O.current=o,Q.current=l.zoom}}if(!F&&g.current&&!T.current)if(h){if(E.current){const o=E.current.children[0];if(o!=null&&o.clientWidth&&o!=null&&o.clientHeight){const{isOrthographicCamera:y}=l;if(y||_)v.scale&&(Array.isArray(v.scale)?v.scale instanceof z?g.current.scale.copy(v.scale.clone().divideScalar(1)):g.current.scale.set(1/v.scale[0],1/v.scale[1],1/v.scale[2]):g.current.scale.setScalar(1/v.scale));else{const p=(j||10)/400,W=o.clientWidth*p,H=o.clientHeight*p;g.current.scale.set(W,H,1)}T.current=!0}}}else{const o=u.children[0];if(o!=null&&o.clientWidth&&o!=null&&o.clientHeight){const y=1/de.factor,p=o.clientWidth*y,W=o.clientHeight*y;g.current.scale.set(p,W,1),T.current=!0}g.current.lookAt(d.camera.position)}});const X=n.useMemo(()=>({vertexShader:h?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[h]);return n.createElement("group",Ee({},v,{ref:m}),c&&!F&&n.createElement("mesh",{castShadow:ie,receiveShadow:ae,ref:g},_||n.createElement("planeGeometry",null),ce||n.createElement("shaderMaterial",{side:we,vertexShader:X.vertexShader,fragmentShader:X.fragmentShader})))});let C=0;const Ae=je(e=>(L.onStart=(t,r,s)=>{e({active:!0,item:t,loaded:r,total:s,progress:(r-C)/(s-C)*100})},L.onLoad=()=>{e({active:!1})},L.onError=t=>e(r=>({errors:[...r.errors,t]})),L.onProgress=(t,r,s)=>{r===s&&(C=s),e({active:!0,item:t,loaded:r,total:s,progress:(r-C)/(s-C)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0})),Ne=()=>{const{progress:e}=Ae();return N.jsxs(ze,{as:"div",center:!0,style:{display:"flex",justifyContent:"center",alignItems:"center",flexDirection:"column"},children:[N.jsx("span",{className:"canvas-loader"}),N.jsxs("p",{className:"loader-text",children:[e.toFixed(2),"%"]})]})};export{Ne as default};
